import fs from "node:fs";
import path from "node:path";
import { rpc } from "@cityofzion/neon-js";
export interface GenerateOptions {
  manifest?: string;
  node?: string;
  out?: string;
  name?: string;
  hash?: string;
  impl?: boolean;
  embedHash?: boolean;
}

export interface N3ManifestMethodParam {
  name: string;
  type: string;
}

export interface N3ManifestMethod {
  name: string;
  parameters: N3ManifestMethodParam[];
  returntype: string;
  safe?: boolean;
}

export interface N3ManifestAbi {
  methods: N3ManifestMethod[];
}

export interface N3ContractManifest {
  name: string;
  abi: N3ManifestAbi;
}

function readJsonFile<T>(filePath: string): T {
  const data = fs.readFileSync(filePath, "utf8");
  return JSON.parse(data) as T;
}

function ensureDirSync(dir: string): void {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

const SHARED_TYPES_FILENAME = "n3-typegen-types.ts";

function emitSharedTypes(outDir: string): void {
  const header = [
    `// Auto-generated by n3-typegen. Do not edit.`,
    `export enum N3TypegenWitnessScope {`,
    `  None = 0,`,
    `  CalledByEntry = 0x01,`,
    `  CustomContracts = 0x10,`,
    `  CustomGroups = 0x20,`,
    `  WitnessRules = 0x40,`,
    `  Global = 0x80,`,
    `}`,
    ``,
    `export interface N3TypegenSigner {`,
    `  account: string;`,
    `  scopes: N3TypegenWitnessScope | number;`,
    `  allowedContracts?: string[];`,
    `  allowedGroups?: string[];`,
    `}`,
    ``,
  ].join("\n");
  ensureDirSync(outDir);
  fs.writeFileSync(path.join(outDir, SHARED_TYPES_FILENAME), header, "utf8");
}

function toTsType(n3Type: string): string {
  switch (n3Type) {
    case "Any":
      return "unknown";
    case "String":
      return "string";
    case "Boolean":
      return "boolean";
    case "Integer":
    case "ByteArray":
    case "Hash160":
    case "Hash256":
    case "PublicKey":
      return "string";
    case "Array":
      return "unknown[]";
    case "Map":
      return "Record<string, unknown>";
    case "Void":
      return "void";
    default:
      return "unknown";
  }
}

function generateTypescript(
  manifest: N3ContractManifest,
  meta?: { hash?: string; nameOverride?: string }
): string {
  const lines: string[] = [];
  const name = (meta?.nameOverride ?? manifest.name).replace(/\W+/g, "_");
  lines.push(`// Auto-generated by n3-typegen. Do not edit.`);
  if (meta?.hash) {
    lines.push(`// Contract: ${name} (${meta.hash})`);
  } else {
    lines.push(`// Contract: ${name}`);
  }
  lines.push(`// Generated at: ${new Date().toISOString()}`);
  // Export API interface for class implementation
  const filteredApi = manifest.abi.methods.filter(
    (mm) => mm.name !== "_initialize"
  );
  const apiGroups = new Map<string, N3ManifestMethod[]>();
  for (const m of filteredApi) {
    const arr = apiGroups.get(m.name) ?? [];
    arr.push(m);
    apiGroups.set(m.name, arr);
  }
  lines.push(`export interface ${name}API {`);
  for (const [methodName, variants] of apiGroups) {
    for (const m of variants) {
      const params = m.parameters
        .map((p) => `${p.name}: ${toTsType(p.type)}`)
        .join(", ");
      const ret = toTsType(m.returntype);
      lines.push(`  ${methodName}(${params}): Promise<${ret}>;`);
    }
  }
  lines.push(`}`);
  return lines.join("\n");
}

function generateImplementation(
  manifest: N3ContractManifest,
  meta?: { hash?: string; nameOverride?: string },
  options?: { embedHash?: boolean }
): string {
  const name = (meta?.nameOverride ?? manifest.name).replace(/\W+/g, "_");
  const className = `${name}Client`;
  const hasStaticHash = Boolean(meta?.hash && options?.embedHash);
  const lines: string[] = [];
  lines.push(`// Auto-generated by n3-typegen. Do not edit.`);
  if (meta?.hash) {
    lines.push(`// Contract: ${name} (${meta.hash})`);
  } else {
    lines.push(`// Contract: ${name}`);
  }
  lines.push(`// Generated at: ${new Date().toISOString()}`);
  lines.push("");
  lines.push(`import type { ${name}API } from "./${name}";`);
  lines.push(
    `import type { N3TypegenSigner } from "./${SHARED_TYPES_FILENAME.replace(
      /\\.ts$/,
      ""
    )}";`
  );
  lines.push("");
  lines.push(`export interface N3Invoker {`);
  lines.push(
    `  invoke<T>(contractHash: string, method: string, args: unknown[], signers?: N3TypegenSigner[]): Promise<T>;`
  );
  lines.push(
    `  invokeRead<T>(contractHash: string, method: string, args: unknown[]): Promise<T>;`
  );
  lines.push(`}`);
  lines.push("");
  lines.push(`export class ${className} implements ${name}API {`);
  lines.push(`  private readonly invoker: N3Invoker;`);
  if (hasStaticHash) {
    lines.push(`  private static readonly CONTRACT_HASH = "${meta?.hash}";`);
  } else {
    lines.push(`  private readonly contractHash: string;`);
  }
  lines.push("");
  if (hasStaticHash) {
    lines.push(`  constructor(invoker: N3Invoker) {`);
    lines.push(`    this.invoker = invoker;`);
    lines.push(`  }`);
  } else {
    lines.push(`  constructor(invoker: N3Invoker, contractHash: string) {`);
    lines.push(`    this.invoker = invoker;`);
    lines.push(`    this.contractHash = contractHash;`);
    lines.push(`  }`);
  }
  lines.push("");
  const filteredImpl = manifest.abi.methods.filter(
    (mm) => mm.name !== "_initialize"
  );
  const implGroups = new Map<string, N3ManifestMethod[]>();
  for (const m of filteredImpl) {
    const arr = implGroups.get(m.name) ?? [];
    arr.push(m);
    implGroups.set(m.name, arr);
  }
  const contractExpr = hasStaticHash
    ? `${className}.CONTRACT_HASH`
    : `this.contractHash`;
  for (const [methodName, variants] of implGroups) {
    for (const m of variants) {
      const paramsSig = m.parameters
        .map((p) => `${p.name}: ${toTsType(p.type)}`)
        .join(", ");
      const ret = toTsType(m.returntype);
      lines.push(`  ${methodName}(${paramsSig}): Promise<${ret}>;`);
    }
    const allRets = Array.from(
      new Set(variants.map((v) => toTsType(v.returntype)))
    );
    const implRet = allRets.length === 1 ? allRets[0] : "unknown";
    const allSafe = variants.every((v) => Boolean((v as any).safe));
    const invokerMethod = allSafe ? "invokeRead" : "invoke";
    if (!allSafe) {
      // extra overload with signer options for write methods
      const anyVariant = variants[0];
      const baseParams = anyVariant.parameters
        .map((p) => `${p.name}: ${toTsType(p.type)}`)
        .join(", ");
      const optSep = baseParams.length ? ", " : "";
      lines.push(
        `  ${methodName}(${baseParams}${optSep}options?: { signers?: N3TypegenSigner[] }): Promise<${implRet}>;`
      );
    }
    lines.push(
      `  async ${methodName}(...args: unknown[]): Promise<${implRet}> {`
    );
    if (invokerMethod === "invoke") {
      lines.push(`    const last = args[args.length - 1];`);
      lines.push(
        `    const options = last && typeof last === "object" && !Array.isArray(last) && (last as any).signers ? (args.pop() as { signers?: N3TypegenSigner[] }) : undefined;`
      );
      lines.push(
        `    return await this.invoker.invoke<${implRet}>(${contractExpr}, "${methodName}", args as unknown[], options?.signers);`
      );
    } else {
      lines.push(
        `    return await this.invoker.invokeRead<${implRet}>(${contractExpr}, "${methodName}", args as unknown[]);`
      );
    }
    lines.push(`  }`);
    lines.push("");
  }
  lines.push(`}`);
  return lines.join("\n");
}

async function fetchManifestFromNode(
  nodeUrl: string,
  hash: string
): Promise<N3ContractManifest> {
  const client = new rpc.RPCClient(nodeUrl);
  const res = await client.getContractState(hash);
  const manifest =
    typeof res?.manifest === "string"
      ? JSON.parse(res.manifest)
      : res?.manifest;
  if (!manifest?.abi?.methods) {
    throw new Error("Failed to fetch/parse manifest from node");
  }
  return manifest as N3ContractManifest;
}

export async function generate(options: GenerateOptions): Promise<void> {
  const {
    manifest: manifestPath = "",
    node: nodeUrl,
    out = "src/contracts",
  } = options;
  if (!manifestPath && !nodeUrl) {
    throw new Error("Provide either --manifest <path> or --node <url>");
  }
  let mf: N3ContractManifest;
  if (nodeUrl) {
    if (!options.hash) {
      throw new Error("--node requires --hash to locate the contract");
    }
    mf = await fetchManifestFromNode(nodeUrl, options.hash);
  } else {
    mf = readJsonFile<N3ContractManifest>(manifestPath);
  }
  const content = generateTypescript(mf, {
    hash: options.hash,
    nameOverride: options.name,
  });
  ensureDirSync(out);
  const outfile = path.join(
    out,
    `${(options.name ?? mf.name).replace(/\W+/g, "_")}.d.ts`
  );
  fs.writeFileSync(outfile, content, "utf8");
  // eslint-disable-next-line no-console
  console.log(`Generated: ${outfile}`);

  if (options.impl) {
    emitSharedTypes(out);
    const implContent = generateImplementation(
      mf,
      {
        hash: options.hash,
        nameOverride: options.name,
      },
      { embedHash: Boolean(options.embedHash) }
    );
    const implOutfile = path.join(
      out,
      `${(options.name ?? mf.name).replace(/\W+/g, "_")}Client.ts`
    );
    fs.writeFileSync(implOutfile, implContent, "utf8");
    // eslint-disable-next-line no-console
    console.log(`Generated: ${implOutfile}`);
  }
}
